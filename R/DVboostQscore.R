#' Generate Q scores for all SVs
#'
#' After training procedure, DVboost assigns Q scores to each SV based on training on a subset of SVs (only DEL). The higher the Q score, the more likely it is a true SV.
#' @param DVb.res output generated by \code{\link{runDVboostwrapper}}
#' @param tmp.mtx output generated by \code{\link{loadVariants}}
#' @return A data.frame with same format as \code{tmp.mtx} with one additional field \code{Qscore}
#' @examples
#' data(ExampleData, package='DVboost')
#' sample <- gsub('_PE', '', grep('_PE$', colnames(ExampleData), value=TRUE))
#' outdir <- getwd()
#' tmp.mtx.DEL <- ExampleData[ExampleData$SVType == 'DEL',]
#' truth.vec <- tmp.mtx.DEL$CNVMAP == 1 | tmp.mtx.DEL$CNVR ==1
#' is.semi.truth.vec <- as.numeric(truth.vec)
#' DVb.res <- runDVboostwrapper( var.atr.mtx = tmp.mtx.DEL, var.ID.vec = rownames(tmp.mtx.DEL),
#'                              is.known.var.vec = is.semi.truth.vec,
#'                              output.DIR.name = outdir, bySVlength=FALSE)
#' outmat <- DVboostQscore(DVb.res, ExampleData)
#'
#' @seealso
#' \code{\link{runDVboostwrapper}}
#'
#' @export
#' @import gbm


DVboostQscore <- function(DVb.res, tmp.mtx){
  DV.fit.res1 <- DVb.res$DVboost.res
  bestTreeForPrediction <- gbm.perf(DV.fit.res1,plot.it = F)
  tmp.mtx.else <- tmp.mtx[tmp.mtx$SVType != 'DEL',]
  pred <- predict(DV.fit.res1 ,tmp.mtx.else, n.trees=bestTreeForPrediction, type = 'response')
  DVboost.ECDF <- ecdf(DV.fit.res1$fitted.values[which(DV.fit.res1$is.known.variant==1)])
  DVboost.Q.score <- DVboost.ECDF(c(DV.fit.res1$fitted.values,pred))
  outmat <- rbind(tmp.mtx[tmp.mtx$SVType == 'DEL',], tmp.mtx.else)
  outmat$Qscore <- DVboost.Q.score
}
